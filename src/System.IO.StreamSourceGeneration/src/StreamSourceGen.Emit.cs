// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace System.IO.StreamSourceGeneration
{
    public partial class StreamSourceGen
    {
        private static void Emit(StringBuilder sb, StreamTypeInfo streamTypeInfo)
        {
            sb.Append($@"// <auto-generated/>

#nullable enable

{StreamBoilerplateConstants.UsingDirectives}

namespace {streamTypeInfo.TypeSymbol.ContainingNamespace}
{{");
            sb.Append($@"
    partial class {streamTypeInfo.TypeSymbol.Name}
    {{");
            foreach (BoilerplateCandidateInfo candidateInfo in BoilerplateCandidateInfo.CandidatesList)
            {
                StreamMember member = candidateInfo.StreamMember;
                if (streamTypeInfo.OverriddenMembers.Contains(member))
                {
                    continue;
                }

                string boilerplate;
                switch (member)
                {
                    case StreamMember.ReadBytes:
                    case StreamMember.ReadSpan:
                    case StreamMember.ReadAsyncBytes:
                    case StreamMember.ReadAsyncMemory:
                    case StreamMember.WriteBytes:
                    case StreamMember.WriteSpan:
                    case StreamMember.WriteAsyncBytes:
                    case StreamMember.WriteAsyncMemory:
                        StreamCapabilityInfo? capabilityInfo = member.IsRead() ?
                            streamTypeInfo.ReadInfo : streamTypeInfo.WriteInfo;

                        if (capabilityInfo == null)
                        {
                            boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        }
                        else
                        {
                            // Determine preferred method to call for the to-be-generated method.
                            StreamMember memberToCall = member.IsAsync() ?
                                capabilityInfo.GetAsyncPreferredMember() : capabilityInfo.GetSyncPreferredMember();

                            string? memberToCallTemplate = GetMemberToCallForTemplate(member, memberToCall);

                            if (memberToCallTemplate == null)
                            {
                                continue;
                            }
                            boilerplate = string.Format(candidateInfo.Boilerplate, memberToCallTemplate);
                        }
                        break;
                    case StreamMember.ReadByte:
                        if (streamTypeInfo.ReadInfo?.GetSyncPreferredMember() is not StreamMember.ReadSpan)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    case StreamMember.WriteByte:
                        if (streamTypeInfo.WriteInfo?.GetSyncPreferredMember() is not StreamMember.WriteSpan)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    case StreamMember.BeginRead:
                    case StreamMember.CanRead:
                    case StreamMember.EndRead:
                        boilerplate = streamTypeInfo.CanRead ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.BeginWrite:
                    case StreamMember.CanWrite:
                    case StreamMember.EndWrite:
                        boilerplate = streamTypeInfo.CanWrite ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.SetLength:
                        if (streamTypeInfo.CanSeek && streamTypeInfo.CanWrite)
                        {
                            continue;
                        }
                        // We can easily generate SetLength if not supported but not otherwise.
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.Position:
                    case StreamMember.Length:
                        if (streamTypeInfo.CanSeek)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.CanSeek:
                        boilerplate = streamTypeInfo.CanSeek ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.Flush:
                        // We emit Flush as an empty method.
                        // If the Stream supports writing, we report a "Consider implementing Flush()" diagnostic.
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    default:
                        // If Seek wasn't contained in overriddenMembers, it means
                        // that it wasn't implemented and seeking is not supported.
                        Debug.Assert(member is StreamMember.Seek);
                        Debug.Assert(!streamTypeInfo.CanSeek);
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                }

                sb.Append(boilerplate);
            }

            sb.Append(StreamBoilerplateConstants.Helpers);
            sb.Append(@"
    }
}");
        }

        /// <summary>
        /// Gets the boilerplate/template for the specific combination of the specified <paramref name="member"/>
        /// and <paramref name="memberToCall"/>
        /// </summary>
        /// <returns>The template to use for the specified combination or <see langword="null" /> if its best to call 
        /// the base implementation.</returns>
        internal static string? GetMemberToCallForTemplate(StreamMember member, StreamMember memberToCall)
        {
            return member switch
            {
                StreamMember.ReadBytes => memberToCall switch
                {
                    StreamMember.ReadSpan => StreamBoilerplateConstants.ReadBytesCallsToReadSpan,
                    StreamMember.ReadAsyncBytes => StreamBoilerplateConstants.ReadBytesCallsToReadAsyncBytes,
                    StreamMember.ReadAsyncMemory => StreamBoilerplateConstants.ReadBytesCallsToReadAsyncMemory,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.ReadSpan => memberToCall switch
                {
                    StreamMember.ReadBytes => null,
                    StreamMember.ReadAsyncBytes => StreamBoilerplateConstants.ReadSpanCallsToReadAsyncBytes,
                    StreamMember.ReadAsyncMemory => StreamBoilerplateConstants.ReadSpanCallsToReadAsyncMemory,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.ReadAsyncBytes => memberToCall switch
                {
                    StreamMember.ReadBytes => StreamBoilerplateConstants.ReadAsyncBytesCallsToReadBytes,
                    StreamMember.ReadSpan => StreamBoilerplateConstants.ReadAsyncBytesCallsToReadSpan,
                    StreamMember.ReadAsyncMemory => StreamBoilerplateConstants.ReadAsyncBytesCallsToReadAsyncMemory,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.ReadAsyncMemory => memberToCall switch
                {
                    StreamMember.ReadBytes => StreamBoilerplateConstants.ReadAsyncMemoryCallsToReadBytes,
                    StreamMember.ReadSpan => null,
                    StreamMember.ReadAsyncBytes => null,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.WriteBytes => memberToCall switch
                {
                    StreamMember.WriteSpan => StreamBoilerplateConstants.WriteBytesCallsToWriteSpan,
                    StreamMember.WriteAsyncBytes => StreamBoilerplateConstants.WriteBytesCallsToWriteAsyncBytes,
                    StreamMember.WriteAsyncMemory => StreamBoilerplateConstants.WriteBytesCallsToWriteAsyncMemory,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.WriteSpan => memberToCall switch
                {
                    StreamMember.WriteBytes => null,
                    StreamMember.WriteAsyncBytes => StreamBoilerplateConstants.WriteSpanCallsToWriteAsyncBytes,
                    StreamMember.WriteAsyncMemory => StreamBoilerplateConstants.WriteSpanCallsToWriteAsyncMemory,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.WriteAsyncBytes => memberToCall switch
                {
                    StreamMember.WriteBytes => StreamBoilerplateConstants.WriteAsyncBytesCallsToWriteBytes,
                    StreamMember.WriteSpan => StreamBoilerplateConstants.WriteAsyncBytesCallsToWriteSpan,
                    StreamMember.WriteAsyncMemory => StreamBoilerplateConstants.WriteAsyncBytesCallsToWriteAsyncMemory,
                    _ => throw new InvalidOperationException()
                },
                StreamMember.WriteAsyncMemory => memberToCall switch
                {
                    StreamMember.WriteBytes => StreamBoilerplateConstants.WriteAsyncMemoryCallsToWriteBytes,
                    StreamMember.WriteSpan => null,
                    StreamMember.WriteAsyncBytes => null,
                    _ => throw new InvalidOperationException()
                },
                _ => throw new InvalidOperationException()
            };
        }
    }
}
