// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace System.IO.StreamSourceGeneration
{
    [Generator]
    public partial class StreamSourceGen : IIncrementalGenerator
    {
        internal const string StreamBoilerplateAttributeFullName = "System.IO.GenerateStreamBoilerplateAttribute";
        internal const string StreamFullName = "System.IO.Stream";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("TaskToApm.g.cs", StreamBoilerplateConstants.TaskToApm);
            });

            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    StreamBoilerplateAttributeFullName,
                    predicate: (node, _) => node is ClassDeclarationSyntax c && c.Modifiers.Any(SyntaxKind.PartialKeyword),
                    transform: (context, _) => (ClassDeclarationSyntax)context.TargetNode);

            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty)
            {
                return;
            }

#if LAUNCH_DEBUGGER
        if (!Diagnostics.Debugger.IsAttached)
        {
            Diagnostics.Debugger.Launch();
        }
#endif

            List<StreamTypeInfo>? classesWithGenerationOptions = 
                Helpers.GetClassesWithGenerationOptions(compilation, classes, context.CancellationToken);

            if (classesWithGenerationOptions == null)
            {
                return;
            }

            StringBuilder sb = new();

            foreach (StreamTypeInfo streamTypeInfo in classesWithGenerationOptions)
            {
                sb.Clear();
                Emit(sb, streamTypeInfo);

                INamedTypeSymbol typeSymbol = streamTypeInfo.TypeSymbol;
                string hintName = $"{typeSymbol.ContainingNamespace}.{typeSymbol.Name}.Boilerplate.g.cs";
                context.AddSource(hintName, sb.ToString());
            }
        }

        private static void Emit(StringBuilder sb, StreamTypeInfo streamTypeInfo)
        {
            sb.Append($@"// <auto-generated/>

#nullable enable

{StreamBoilerplateConstants.UsingDirectives}

namespace {streamTypeInfo.TypeSymbol.ContainingNamespace}
{{");
            sb.Append($@"
    partial class {streamTypeInfo.TypeSymbol.Name}
    {{");

            HashSet<StreamMember> overriddenMembers = streamTypeInfo.OverriddenMembers;

            // Read*/Write*/Seek can hint that a stream CanRead/Write/Seek => true but not vice versa.
            bool canRead = streamTypeInfo.ReadInfo != null;
            bool canWrite = streamTypeInfo.WriteInfo != null;
            bool canSeek = overriddenMembers.Contains(StreamMember.Seek);

            foreach (BoilerplateCandidateInfo candidateInfo in BoilerplateCandidateInfo.CandidatesList)
            {
                StreamMember member = candidateInfo.StreamMember;
                if (overriddenMembers.Contains(member))
                {
                    continue;
                }

                string boilerplate;

                switch (member)
                {
                    case StreamMember.ReadBytes:
                    case StreamMember.ReadSpan:
                    case StreamMember.ReadAsyncBytes:
                    case StreamMember.ReadAsyncMemory:
                    case StreamMember.WriteBytes:
                    case StreamMember.WriteSpan:
                    case StreamMember.WriteAsyncBytes:
                    case StreamMember.WriteAsyncMemory:
                        StreamCapabilityInfo? capabilityInfo = member.IsRead() ?
                            streamTypeInfo.ReadInfo : streamTypeInfo.WriteInfo;

                        if (capabilityInfo == null)
                        {
                            boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        }
                        else
                        {
                            // Determine preferred method to call for the to-be-generated method.
                            StreamMember memberToCall = capabilityInfo.GetPreferredMember(member.IsAsync());
                            string? memberToCallTemplate = Helpers.GetMemberToCallForTemplate(member, memberToCall);

                            if (memberToCallTemplate == null)
                            {
                                continue;
                            }
                            boilerplate = string.Format(candidateInfo.Boilerplate, memberToCallTemplate);
                        }
                        break;
                    case StreamMember.ReadByte:
                        if (streamTypeInfo.ReadInfo?.SyncPreferredMember is not StreamMember.ReadSpan)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    case StreamMember.WriteByte:
                        if (streamTypeInfo.WriteInfo?.SyncPreferredMember is not StreamMember.WriteSpan)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    case StreamMember.BeginRead:
                    case StreamMember.CanRead:
                    case StreamMember.EndRead:
                        boilerplate = canRead ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.BeginWrite:
                    case StreamMember.CanWrite:
                    case StreamMember.EndWrite:
                        boilerplate = canWrite ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.SetLength:
                        if (canSeek && canWrite)
                        {
                            continue;
                        }
                        // We can easily generate SetLength if not supported but not otherwise.
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.Position:
                    case StreamMember.Length:
                        if (canSeek)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.CanSeek:
                        boilerplate = canSeek ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    default:
                        // If Seek wasn't contained in overriddenMembers, it means
                        // that it wasn't implemented and seeking is not supported.
                        Debug.Assert(member is StreamMember.Seek);
                        Debug.Assert(!canSeek);
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                }

                sb.Append(boilerplate);
            }

            sb.Append(StreamBoilerplateConstants.Helpers);
            sb.Append(@"
    }
}");
        }
    }
}