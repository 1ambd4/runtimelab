// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace System.IO.StreamSourceGeneration
{
    [Generator]
    public partial class StreamSourceGen : IIncrementalGenerator
    {
        internal const string StreamBoilerplateAttributeFullName = "System.IO.GenerateStreamBoilerplateAttribute";
        internal const string StreamFullName = "System.IO.Stream";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("TaskToApm.g.cs", StreamBoilerplateConstants.TaskToApm);
            });

            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    StreamBoilerplateAttributeFullName,
                    predicate: (node, _) => node is ClassDeclarationSyntax c && c.Modifiers.Any(SyntaxKind.PartialKeyword),
                    transform: (context, _) => (ClassDeclarationSyntax)context.TargetNode);

            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty)
            {
                return;
            }

#if LAUNCH_DEBUGGER
            if (!Diagnostics.Debugger.IsAttached)
            {
                Diagnostics.Debugger.Launch();
            }
#endif

            List<StreamTypeInfo>? classesWithGenerationOptions = 
                Helpers.GetClassesWithGenerationOptions(compilation, classes, context.CancellationToken);

            if (classesWithGenerationOptions == null)
            {
                return;
            }

            StringBuilder sb = new();

            foreach (StreamTypeInfo streamTypeInfo in classesWithGenerationOptions)
            {
                sb.Clear();
                Emit(sb, streamTypeInfo);

                INamedTypeSymbol typeSymbol = streamTypeInfo.TypeSymbol;
                string hintName = $"{typeSymbol.ContainingNamespace}.{typeSymbol.Name}.Boilerplate.g.cs";
                context.AddSource(hintName, sb.ToString());

                ReportDiagnostics(context, streamTypeInfo);
            }
        }

        private static void Emit(StringBuilder sb, StreamTypeInfo streamTypeInfo)
        {
            sb.Append($@"// <auto-generated/>

#nullable enable

{StreamBoilerplateConstants.UsingDirectives}

namespace {streamTypeInfo.TypeSymbol.ContainingNamespace}
{{");
            sb.Append($@"
    partial class {streamTypeInfo.TypeSymbol.Name}
    {{");

            HashSet<StreamMember> overriddenMembers = streamTypeInfo.OverriddenMembers;

            foreach (BoilerplateCandidateInfo candidateInfo in BoilerplateCandidateInfo.CandidatesList)
            {
                StreamMember member = candidateInfo.StreamMember;
                if (overriddenMembers.Contains(member))
                {
                    continue;
                }

                string boilerplate;
                switch (member)
                {
                    case StreamMember.ReadBytes:
                    case StreamMember.ReadSpan:
                    case StreamMember.ReadAsyncBytes:
                    case StreamMember.ReadAsyncMemory:
                    case StreamMember.WriteBytes:
                    case StreamMember.WriteSpan:
                    case StreamMember.WriteAsyncBytes:
                    case StreamMember.WriteAsyncMemory:
                        StreamCapabilityInfo? capabilityInfo = member.IsRead() ?
                            streamTypeInfo.ReadInfo : streamTypeInfo.WriteInfo;

                        if (capabilityInfo == null)
                        {
                            boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        }
                        else
                        {
                            // Determine preferred method to call for the to-be-generated method.
                            StreamMember memberToCall = member.IsAsync() ? 
                                capabilityInfo.GetAsyncPreferredMember() : capabilityInfo.GetSyncPreferredMember();

                            string? memberToCallTemplate = Helpers.GetMemberToCallForTemplate(member, memberToCall);

                            if (memberToCallTemplate == null)
                            {
                                continue;
                            }
                            boilerplate = string.Format(candidateInfo.Boilerplate, memberToCallTemplate);
                        }
                        break;
                    case StreamMember.ReadByte:
                        if (streamTypeInfo.ReadInfo?.GetSyncPreferredMember() is not StreamMember.ReadSpan)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    case StreamMember.WriteByte:
                        if (streamTypeInfo.WriteInfo?.GetSyncPreferredMember() is not StreamMember.WriteSpan)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.Boilerplate!;
                        break;
                    case StreamMember.BeginRead:
                    case StreamMember.CanRead:
                    case StreamMember.EndRead:
                        boilerplate = streamTypeInfo.CanRead ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.BeginWrite:
                    case StreamMember.CanWrite:
                    case StreamMember.EndWrite:
                        boilerplate = streamTypeInfo.CanWrite ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.SetLength:
                        if (streamTypeInfo.CanSeek && streamTypeInfo.CanWrite)
                        {
                            continue;
                        }
                        // We can easily generate SetLength if not supported but not otherwise.
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.Position:
                    case StreamMember.Length:
                        if (streamTypeInfo.CanSeek)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.CanSeek:
                        boilerplate = streamTypeInfo.CanSeek ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported!;
                        break;
                    case StreamMember.Flush:
                        // We emit Flush as an empty method.
                        // If the Stream supports writing, we report a "Consider implementing Flush()" diagnostic.
                        boilerplate =  candidateInfo.Boilerplate!;
                        break;
                    default:
                        // If Seek wasn't contained in overriddenMembers, it means
                        // that it wasn't implemented and seeking is not supported.
                        Debug.Assert(member is StreamMember.Seek);
                        Debug.Assert(!streamTypeInfo.CanSeek);
                        boilerplate = candidateInfo.BoilerplateForUnsupported!;
                        break;
                }

                sb.Append(boilerplate);
            }

            sb.Append(StreamBoilerplateConstants.Helpers);
            sb.Append(@"
    }
}");
        }

        // Diagnostics
        // Stream does not support read or write
        private static readonly DiagnosticDescriptor s_TypeDoesNotImplementReadOrWrite =
            new DiagnosticDescriptor(
                id: "FOOBAR001",
                title: "Type does not implement any Read or Write",
                messageFormat: "'{0}' does not implement any Read or Write method",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        // Sync-over-async or async-over-sync
        private static readonly DiagnosticDescriptor s_ReadDoingAsyncOverSync =
            new DiagnosticDescriptor(
                id: "FOOBAR002",
                title: "Stream does Read as async-over-sync",
                messageFormat: "'{0}' does not implement any Read method and hence is doing async-over-sync",
                category: "StreamSourceGen", DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_ReadAsyncDoingSyncOverAsync =
            new DiagnosticDescriptor(
                id: "FOOBAR003",
                title: "Stream does ReadAsync as sync-over-async",
                messageFormat: "'{0}' does not implement any ReadAsync method and hence is doing sync-over-async",
                category: "StreamSourceGen", DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_WriteDoingAsyncOverSync =
            new DiagnosticDescriptor(
                id: "FOOBAR004",
                title: "Stream does Write as async-over-sync",
                messageFormat: "'{0}' does not implement any Write method and hence is doing async-over-sync",
                category: "StreamSourceGen", DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_WriteAsyncDoingSyncOverAsync =
            new DiagnosticDescriptor(
                id: "FOOBAR005",
                title: "Stream does WriteAsync as sync-over-async",
                messageFormat: "'{0}' does not implement any WriteAsync method and hence is doing sync-over-async",
                category: "StreamSourceGen", DiagnosticSeverity.Info, isEnabledByDefault: true);
        
        // Consider Span/Memory overloads for better performance
        private static readonly DiagnosticDescriptor s_ConsiderImplementingReadSpan =
            new DiagnosticDescriptor(
                id: "FOOBAR006",
                title: "Consider implementing Read(Span<byte>)",
                messageFormat: "'{0}' does not implement Read(Span<byte>), for better performance, consider providing an implementation for Read(Span<byte>) and make other Read methods overloads to it",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_ConsiderImplementingWriteReadOnlySpan =
            new DiagnosticDescriptor(
                id: "FOOBAR007",
                title: "Consider implementing Write(ReadOnlySpan<byte>)",
                messageFormat: "'{0}' does not implement Write(ReadOnlySpan<byte>), for better performance, consider providing an implementation for Write(ReadOnlySpan<byte>) and make other Write overloads defer to it",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_ConsiderImplementingReadAsyncMemory =
            new DiagnosticDescriptor(
                id: "FOOBAR008",
                title: "Consider implementing ReadAsync(Memory<byte>, CancellationToken)",
                messageFormat: "'{0}' does not implement ReadAsync(Memory<byte>, CancellationToken), for better performance, consider providing an implementation for ReadAsync(Memory<byte>, CancellationToken) and make other ReadAsync overloads defer to it",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_ConsiderImplementingWriteAsyncReadOnlyMemory =
            new DiagnosticDescriptor(
                id: "FOOBAR009",
                title: "Consider implementing WriteAsync(ReadOnlyMemory<byte>, CancellationToken)",
                messageFormat: "'{0}' does not implement WriteAsync(ReadOnlyMemory<byte>, CancellationToken), for better performance, consider providing an implementation for WriteAsync(ReadOnlyMemory<byte>, CancellationToken) and make other WriteAsync overloads defer to it",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        // Avoid implementing APM (Begin/End) methods
        private static readonly DiagnosticDescriptor s_AvoidBeginReadEndRead =
            new DiagnosticDescriptor(
                id: "FOOBAR010",
                title: "Avoid BeingRead or EndRead",
                messageFormat: "'{0}' implements BeginRead or EndRead, Task-based methods shoud be preferred when possible, consider removing them to allow the source generator to emit an implementation based on Task-based ReadAsync",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_AvoidBeginWriteEndWrite =
            new DiagnosticDescriptor(
                id: "FOOBAR011",
                title: "Avoid BeingWrite or EndWrite",
                messageFormat: "'{0}' implements BeingWrite or EndWrite, Task-based methods shoud be preferred when possible, consider removing them to allow the source generator to emit an implementation based on Task-based WriteAsync",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor s_ConsiderImplementingFlush =
            new DiagnosticDescriptor(
                id: "FOOBAR012",
                title: "Consider implementing Flush() to move any buffered data to its destination",
                messageFormat: "'{0}' does not implement Flush but it implements one or more Write method(s), Consider implementing Flush() to move any buffered data to its destination, clear the buffer, or both",
                category: "StreamSourceGen",
                DiagnosticSeverity.Info, isEnabledByDefault: true);

        private static void ReportDiagnostics(SourceProductionContext context, StreamTypeInfo streamTypeInfo)
        {
            if (!streamTypeInfo.CanRead && !streamTypeInfo.CanWrite)
            {
                context.ReportDiagnostic(CreateDiagnostic(s_TypeDoesNotImplementReadOrWrite, streamTypeInfo));
            }
            else
            {
                if (streamTypeInfo.CanRead) 
                { 
                    ReportReadDiagnostics(context, streamTypeInfo);
                }

                if (streamTypeInfo.CanWrite)
                {
                    ReportWriteDiagnostics(context, streamTypeInfo);
                }
            }

            if (streamTypeInfo.OverriddenMembers.Contains(StreamMember.BeginRead) || 
                streamTypeInfo.OverriddenMembers.Contains(StreamMember.EndRead))
            {
                context.ReportDiagnostic(CreateDiagnostic(s_AvoidBeginReadEndRead, streamTypeInfo));
            }

            if (streamTypeInfo.OverriddenMembers.Contains(StreamMember.BeginWrite) || 
                streamTypeInfo.OverriddenMembers.Contains(StreamMember.EndWrite))
            {
                context.ReportDiagnostic(CreateDiagnostic(s_AvoidBeginWriteEndWrite, streamTypeInfo));
            }
        }

        private static void ReportReadDiagnostics(SourceProductionContext context, StreamTypeInfo streamTypeInfo)
        {
            Debug.Assert(streamTypeInfo.CanRead);
            Debug.Assert(streamTypeInfo.ReadInfo is not null);
            StreamCapabilityInfo readInfo = streamTypeInfo.ReadInfo!;

            bool asyncOverSync = readInfo.GetSyncPreferredMember().IsAsync();
            bool syncOverAsync = !readInfo.GetAsyncPreferredMember().IsAsync();
            Debug.Assert(asyncOverSync != syncOverAsync);

            if (asyncOverSync)
            {
                context.ReportDiagnostic(CreateDiagnostic(s_ReadDoingAsyncOverSync, streamTypeInfo));
            }

            if (syncOverAsync)
            {
                context.ReportDiagnostic(CreateDiagnostic(s_ReadAsyncDoingSyncOverAsync, streamTypeInfo));
            }

            if (!asyncOverSync && !streamTypeInfo.OverriddenMembers.Contains(StreamMember.ReadSpan))
            {
                context.ReportDiagnostic(CreateDiagnostic(s_ConsiderImplementingReadSpan, streamTypeInfo));
            }

            if (!syncOverAsync && !streamTypeInfo.OverriddenMembers.Contains(StreamMember.ReadAsyncMemory))
            {
                context.ReportDiagnostic(CreateDiagnostic(s_ConsiderImplementingReadAsyncMemory, streamTypeInfo));
            }
        }

        private static void ReportWriteDiagnostics(SourceProductionContext context, StreamTypeInfo streamTypeInfo)
        {
            Debug.Assert(streamTypeInfo.CanWrite);
            Debug.Assert(streamTypeInfo.WriteInfo is not null);
            StreamCapabilityInfo writeInfo = streamTypeInfo.WriteInfo!;

            bool asyncOverSync = writeInfo.GetSyncPreferredMember().IsAsync();
            bool syncOverAsync = !writeInfo.GetAsyncPreferredMember().IsAsync();
            Debug.Assert(asyncOverSync != syncOverAsync);

            if (asyncOverSync)
            {
                context.ReportDiagnostic(CreateDiagnostic(s_WriteDoingAsyncOverSync, streamTypeInfo));
            }

            if (syncOverAsync)
            {
                context.ReportDiagnostic(CreateDiagnostic(s_WriteAsyncDoingSyncOverAsync, streamTypeInfo));
            }

            if (!asyncOverSync && !streamTypeInfo.OverriddenMembers.Contains(StreamMember.WriteSpan))
            {
                context.ReportDiagnostic(CreateDiagnostic(s_ConsiderImplementingWriteReadOnlySpan, streamTypeInfo));
            }

            if (!syncOverAsync && !streamTypeInfo.OverriddenMembers.Contains(StreamMember.WriteAsyncMemory))
            {
                context.ReportDiagnostic(CreateDiagnostic(s_ConsiderImplementingWriteAsyncReadOnlyMemory, streamTypeInfo));
            }

            if (!streamTypeInfo.OverriddenMembers.Contains(StreamMember.Flush))
            { 
                context.ReportDiagnostic(CreateDiagnostic(s_ConsiderImplementingFlush, streamTypeInfo));
            }
        }

        private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, StreamTypeInfo streamTypeInfo)
            => Diagnostic.Create(descriptor, Location.None, streamTypeInfo.TypeSymbol.Name);
    }
}