using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.DotnetRuntime.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace System.IO.StreamSourceGeneration;

[Generator]
public partial class StreamSourceGen : IIncrementalGenerator
{
    private const string StreamBoilerplateAttributeFullName = "System.IO.StreamSourceGeneration.GenerateStreamBoilerplateAttribute";
    private const string StreamFullName = "System.IO.Stream";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            //Debugger.Launch();
            ctx.AddSource("TaskToApm.g.cs", System.IO.StreamSourceGeneration.Properties.Resources.TaskToApm);
        });

        IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                StreamBoilerplateAttributeFullName,
                predicate: (node, _) => node is ClassDeclarationSyntax c && c.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: (context, _) => (ClassDeclarationSyntax)context.TargetNode);

        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
            context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        //Debugger.Launch();

        List<StreamTypeInfo>? classesWithGenerationOptions = GetClassesWithGenerationOptions(compilation, classes, context.CancellationToken);

        if (classesWithGenerationOptions == null)
        {
            return;
        }

        StringBuilder sb = new();

        foreach (StreamTypeInfo streamTypeInfo in classesWithGenerationOptions)
        {
            sb.Clear();
            Emit(sb, streamTypeInfo);

            INamedTypeSymbol typeSymbol = streamTypeInfo.TypeSymbol;
            string hintName = $"{typeSymbol.ContainingNamespace}.{typeSymbol.Name}.Boilerplate.g.cs";
            context.AddSource(hintName, sb.ToString());
        }
    }

    private static void Emit(StringBuilder sb, StreamTypeInfo streamTypeInfo)
    {
        sb.Append($@"// <auto-generated/>

#nullable enable

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace {streamTypeInfo.TypeSymbol.ContainingNamespace}
{{");
        sb.Append($@"
    partial class {streamTypeInfo.TypeSymbol.Name}
    {{");

        HashSet<string> overriddenMembers = streamTypeInfo.OverriddenMembers;

        // Read*/Write*/Seek can hint that a stream CanRead/Write/Seek => true but not vice versa.
        bool canRead = streamTypeInfo.ReadInfo != null;
        bool canWrite = streamTypeInfo.WriteInfo != null;
        bool canSeek = overriddenMembers.Contains(StreamMembersConstants.Seek);

        foreach (BoilerplateCandidateInfo candidateInfo in BoilerplateCandidateInfo.CandidatesList)
        {
            string candidateName = candidateInfo.Name;

            if (overriddenMembers.Contains(candidateName))
            {
                continue;
            }

            StreamOperationKind candidateOperationKind = candidateInfo.OperationKind;

            if (candidateOperationKind >= StreamOperationKind.Read &&
                candidateOperationKind <= StreamOperationKind.WriteAsync)
            {
                StreamCapabilityInfo? capabilityInfo;
                bool isAsync;

                if (candidateOperationKind == StreamOperationKind.Read) 
                {
                    capabilityInfo = streamTypeInfo.ReadInfo;
                    isAsync = false;
                }
                else if (candidateOperationKind == StreamOperationKind.Write)
                {
                    capabilityInfo = streamTypeInfo.WriteInfo;
                    isAsync = false;
                }
                else if (candidateOperationKind == StreamOperationKind.ReadAsync)
                {
                    capabilityInfo = streamTypeInfo.ReadInfo;
                    isAsync = true;
                }
                else
                {
                    Debug.Assert(candidateOperationKind == StreamOperationKind.WriteAsync);
                    capabilityInfo = streamTypeInfo.WriteInfo;
                    isAsync = true;
                }

                if (capabilityInfo == null)
                {
                    sb.Append(candidateInfo.BoilerplateForUnsupported);
                }
                else
                {
                    // Determine preferred method to call for this generated method.
                    string memberToCall = capabilityInfo.GetPreferredMemberName(isAsync);
                    string memberToCallTemplate = StreamBoilerplateConstants.GetReadMemberToCallForTemplate(candidateName, memberToCall);

                    sb.Append(string.Format(candidateInfo.Boilerplate, memberToCallTemplate));
                }
            }
            else
            {
                string boilerplate;
                switch (candidateName)
                {
                    case StreamMembersConstants.CanRead:
                    case StreamMembersConstants.BeginRead:
                    case StreamMembersConstants.EndRead:
                        boilerplate = canRead ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported;
                        break;
                    case StreamMembersConstants.CanWrite:
                    case StreamMembersConstants.BeginWrite:
                    case StreamMembersConstants.EndWrite:
                        boilerplate = canWrite ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported;
                        break;
                    case StreamMembersConstants.SetLength:
                        if (canSeek && canWrite)
                        {
                            continue;
                        }
                        // We can easily generate SetLength if not supported but not otherwise, unless we emit a partial.
                        boilerplate = candidateInfo.BoilerplateForUnsupported;
                        break;
                    case StreamMembersConstants.Position:
                    case StreamMembersConstants.Length:
                        if (canSeek)
                        {
                            continue;
                        }
                        boilerplate = candidateInfo.BoilerplateForUnsupported;
                        break;
                    case StreamMembersConstants.CanSeek:
                        boilerplate = canSeek ? candidateInfo.Boilerplate! : candidateInfo.BoilerplateForUnsupported;
                        break;
                    default:
                        // If Seek wasn't contained in overriddenMembers, it means that it wasn't implemented and seeking is not supported.
                        Debug.Assert(candidateName is StreamMembersConstants.Seek);
                        Debug.Assert(!canSeek);
                        boilerplate = candidateInfo.BoilerplateForUnsupported;
                        break;
                }

                sb.Append(boilerplate);
            }
        }

        sb.Append(StreamBoilerplateConstants.Helpers);
        sb.Append(@"
    }
}
");
    }

    internal static IEnumerable<string> GetOverriddenMembers(ITypeSymbol symbol)
    {
        return symbol.GetMembers().Select(m => GetOverriddenMember(m)?.ToDisplayString()).Where(s => s != null)!;

        static ISymbol? GetOverriddenMember(ISymbol member)
            => member switch
            {
                IMethodSymbol method => method.OverriddenMethod,
                IPropertySymbol property => property.OverriddenProperty,
                _ => null
            };
    }

    private static List<StreamTypeInfo>? GetClassesWithGenerationOptions(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, CancellationToken cancellationToken)
    {
        INamedTypeSymbol? streamBoilerplateAttributeSymbol = compilation.GetBestTypeByMetadataName(StreamBoilerplateAttributeFullName);
        INamedTypeSymbol? streamSymbol = compilation.GetBestTypeByMetadataName(StreamFullName);

        if (streamBoilerplateAttributeSymbol == null ||
            streamSymbol == null)
        {
            return null;
        }

        List<StreamTypeInfo>? retVal = null;

        foreach (IGrouping<SyntaxTree, ClassDeclarationSyntax> group in classes.GroupBy(c => c.SyntaxTree))
        {
            SyntaxTree syntaxTree = group.Key;
            SemanticModel compilationSemanticModel = compilation.GetSemanticModel(syntaxTree);

            foreach (ClassDeclarationSyntax classNode in group)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (!DerivesFromStream(classNode, streamSymbol, compilationSemanticModel, cancellationToken))
                {
                    continue;
                }

                INamedTypeSymbol typeSymbol = compilationSemanticModel.GetDeclaredSymbol(classNode, cancellationToken)!;

                //AttributeSyntax firstAttribute = classNode.AttributeLists.First().Attributes.First();
                foreach (AttributeListSyntax attributeListSyntax in classNode.AttributeLists)
                {
                    // TODO: test if this fails when type contains multiple attributes.
                    AttributeSyntax attributeSyntax = attributeListSyntax.Attributes.First();
                    IMethodSymbol? attributeSymbol = compilationSemanticModel.GetSymbolInfo(attributeSyntax, cancellationToken).Symbol as IMethodSymbol;

                    if (attributeSymbol == null || 
                        !streamBoilerplateAttributeSymbol.Equals(attributeSymbol.ContainingType, SymbolEqualityComparer.Default))
                    {
                        // badly formed attribute definition, or not the right attribute
                        continue;
                    }

                    //var generationOptions = GetGenerationOptions(attributeSyntax, classSymbol);
                    StreamTypeInfo streamTypeInfo = new(typeSymbol);
                    retVal ??= new List<StreamTypeInfo>();
                    retVal.Add(streamTypeInfo);
                }
            }
        }

        return retVal;
    }

    // TODO: merge this method with DerivesFromJsonSerializerContext.
    private static bool DerivesFromStream(
        ClassDeclarationSyntax classDeclarationSyntax,
        INamedTypeSymbol streamSymbol,
        SemanticModel compilationSemanticModel,
        CancellationToken cancellationToken)
    {
        SeparatedSyntaxList<BaseTypeSyntax>? baseTypeSyntaxList = classDeclarationSyntax.BaseList?.Types;
        if (baseTypeSyntaxList == null)
        {
            return false;
        }

        INamedTypeSymbol? match = null;

        foreach (BaseTypeSyntax baseTypeSyntax in baseTypeSyntaxList)
        {
            INamedTypeSymbol? candidate = compilationSemanticModel.GetSymbolInfo(baseTypeSyntax.Type, cancellationToken).Symbol as INamedTypeSymbol;
            if (candidate != null && streamSymbol.Equals(candidate, SymbolEqualityComparer.Default))
            {
                match = candidate;
                break;
            }
        }

        return match != null;
    }
}
