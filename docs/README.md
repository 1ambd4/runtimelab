# .NET Swift interop tooling documentation

This document provides a detailed overview of the .NET Swift interop tooling, focusing on the projections between Swift and .NET, and the functional design of the tooling. The projection tooling is intended for use with C# and any other .NET language is beyond its scope.

## Usage

The tooling consumes Swift ABI files, which are generated from `.swiftinterface` files by the Swift compiler. This ABI file contains a json representation of the abstract syntax tree of the `.swiftinterface` file. The `.swiftinterface` and `.abi.json` files are generated by executing the `swiftc` command with the `-emit-module-interface` option.

```
Description:
  Swift bindings generator.

Usage:
  SwiftBindings [options]

Options:
  -a, --swiftabi <swiftabi> (REQUIRED)  Path to the Swift ABI file.
  -o, --output <output> (REQUIRED)      Output directory for generated bindings.
  -v, --verbose <verbose>               Prints information about work in process.
  -h, --help                            Display a help message.
  --version                             Show version information
  -?, -h, --help                        Show help and usage information
```

It is possible to specify multiple Swift ABI files for processing. If a unsupported type is encountered, the tooling will ignore it and generate C# source code for known syntax.

## Projections

This section outlines the mappings between Swift and .NET types, and describes how the tool generates C# bindings for a Swift library. For types with similar semantics across Swift and .NET, direct interop is possible and bindings are generated. For types without direct projection, additional Swift wrappers are required and it is the user's responsibility to generate these wrappers. At this stage, the tool is designed to avoid generating any Swift code if possible to avoid complexity of maintaining different Swift compiler and SDK versions. The tool should only generate bindings for Swift types that are part of the stable ABI and don't evolve.

This section will be expanded as more support is introduced.

### Primitive types

The table below lists the Swift types and their corresponding C# types.

| Swift Type                      | C# Type  |
| ------------------------------- | -------- |
| `Swift.Int64`                   | `long`   |
| `Swift.UInt64`                  | `ulong`  |
| `Swift.Int32`                   | `int`    |
| `Swift.UInt32`                  | `uint`   |
| `Swift.Int16`                   | `short`  |
| `Swift.UInt16`                  | `ushort` |
| `Swift.Int8`                    | `sbyte`  |
| `Swift.UInt8`                   | `byte`   |
| `Swift.UnsafePointer`           | `void*`  |
| `Swift.UnsafeMutablePointer`    | `void*`  |
| `Swift.UnsafeRawPointer`        | `void*`  |
| `Swift.UnsafeMutableRawPointer` | `void*`  |
| `Int`                           | `nint`   |
| `UInt`                          | `nuint`  |
| `Bool`                          | `bool`   |
| `Float`                         | `float`  |
| `Double`                        | `double` |

All C# types mentioned are blittable except for `bool`. To facilitate `P/Invoke`, a lightweight wrapper is required to convert `bool` to `byte`. Swift primitive types are implemented as frozen structs that conform to Swift-specific lowering processes handled by the runtime. However, such mapping can fit within the underlying calling convention as these types are below the size limit for being passed by reference.

<details>
The Swift type database is an XML-based file format used for describing primitive data types with the following structure:

```xml
<?xml version="1.0" encoding="utf-8"?>
<swifttypedatabase version="1.0">
    <entities>
        <!-- Individual entities describing Swift data types with C# projections -->
    </entities>
</swifttypedatabase>
```
#### Elements

##### `entities`
- **Description:** Container for individual data type entities.
- **Child Elements:**
    - `entity`: Represents a specific data type in Swift.
        - **Attributes:**
        - `managedNameSpace`: Specifies the managed namespace of the data type.
        - `managedTypeName`: Specifies the managed type name of the data type.
        - **Child Elements:**
        - `typedeclaration`: Represents the declaration of the Swift type.
            - **Attributes:**
            - `kind`: Specifies the kind of type declaration.
            - `name`: Specifies the name of the Swift type.
            - `module`: Specifies the module of the Swift type.
</details>

### Buffer pointers

Swift provides buffer pointer types as non-owning views into memory: `UnsafeRawBufferPointer`, `UnsafeMutableRawBufferPointer`, `UnsafeBufferPointer`, and `UnsafeMutableBufferPointer`. They are implemented as frozen structs within Swift and are projected as structs into C#. The runtime implements Swift structure lowering algorithm, enabling these structs to be passed correctly. Typed buffer pointers are defined with `_Position` and `Count` properties, while raw buffer pointers are defined with `_Position` and `_End`. Surfaced fields on C# side are `BaseAddress` and `Count`. Since these buffer pointers do not allocate or own the memory they point to, memory management is not encapsulated within the structs.

### Static and P/Invoke functions

Each provided module is projected into a separate assembly. The assembly contains a namespace named `<ModuleName>Bindings` and includes a class named `<ModuleName>`. For each public function, a `P/Invoke` signature and a corresponding method are generated. Below is an example to illustrate this process.

Swift library example:
```swift
public func sayHello() {
    print("Hello world")
}
```

User's code in C#:
```csharp
using System;
using HelloLibraryBindings;

namespace HelloWorld
{
    public class Program
    {
        public static void Main(string[] args)
        {
            HelloLibrary.sayHello();
        }
    }
}
```

Generated bindings in C#:
```csharp
using System;
using System.Runtime.InteropServices;
namespace HelloLibraryBindings
{
    public class HelloLibrary
    {
        [DllImport("libHelloLibrary.dylib", EntryPoint = "$s12HelloLibrary03sayA0yyF")]
        internal static extern void PIfunc_sayHello();
        public static void sayHello()
        {
            PIfunc_sayHello();
        }
    }
}
```

In the example, the user's code references the `HelloLibraryBindings` namespace and invokes a static method that has the same name as the Swift function. When the Swift function returns a type, the C# wrapper method also returns type, with additional processing if required. The C# wrapper method is generated only when marshalling is required. If marshalling is not needed, only a P/Invoke declaration is generated.

## Functional outline

The tooling comprises the following components:
- **SwiftBindings**: Command-line interface that orchestrates the tooling workflow.
    - **Components:**
        - `parser`: Parses a Swift library using ABI or Swiftinterface parser.
        - `marshaller`: Marshals types between C# and Swift.
        - `emitter`: Emits a C# bindings library using string-based or object model-based emitter.
- **SwiftRuntime**: Library providing projections of common Swift types. It contains a type database for common Swift types and implements Swift runtime constructs in C#.

The general workflow for generating C# bindings from Swift code is as follows:
1. Consume the Swift ABI file (`.abi.json`) and aggregate the public ABI using a parser that generates module declarations.
2. If needed, generate marshalling information for collected ABI.
3. Generate C# source code using an emitter and generated declarations.

![Functional outline](functional-outline.png)

### Parser

The aggregation of the public ABI is done through the `ISwiftParser` interface. This interface defines the layout for concrete implementations responsible for parsing and collecting ABI information. Two implementations exist: Swift ABI parser and Swift interface parser. The Swift ABI parser aggregates ABI information based on an ABI json file. The Swift interface parser is designed to handle `.swiftinterface` files. The `.swiftinterface` file doesn't contain mangled names, and the parser should consume the dynamic library (`.dylib`) to generate declarations. Currently, the tooling only implements the Swift ABI parser.

### Marshaller

Ideally, marshalling logic should be done between parsing and emitting if possible. The `ModuleDecl`, `MethodDecl`, and `TypeDecl` represents model definition of collected and marshalled Swift ABI that should be projectable into C#.

### Emitter

Two different strategies are available for emitting: using an object model or a string-based approach. The object model, like Roslyn API, represents a full set of C# language. Currently, the tooling only implements the string-based emitter.
